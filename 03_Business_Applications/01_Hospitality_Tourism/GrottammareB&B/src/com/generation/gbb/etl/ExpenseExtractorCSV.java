package com.generation.gbb.etl;

import java.io.FileNotFoundException;
import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import com.generation.gbb.model.entities.Expense;
import com.generation.gbb.model.entities.ExpenseCategory;
import com.generation.library.FileReader;

/**
 * CSV file implementation of ExpenseExtractor.
 * Reads expense data from comma-separated values (CSV) files.
 * No header row expected, ID auto-generated by repository.
 */
public class ExpenseExtractorCSV implements ExpenseExtractor
{
	 /**
     * Extracts expense entities from CSV file.
     * Reads file line by line and converts each row to Expense object.
     * 
     * @param filename Path to CSV file
     * @return List of Expense objects extracted from file
     * @throws FileNotFoundException if file doesn't exist
     */
    @Override
    public List<Expense> extractFrom(String filename) throws FileNotFoundException
    {
    	List<Expense> result = new ArrayList<>();
    	FileReader reader = new FileReader(filename);
    	while(reader.hasNext())
    	{
    		String line = reader.readString();
    		Expense e = convertToObject(line);
    		result.add(e);
    	}    	
    	reader.close();
    	return result;    	
    }
    
    /**
     * Converts CSV line to Expense object.
     * Splits line by comma and maps fields to Expense attributes.
     * 
     * Expected format: date,description,value,category
     * 
     * @param line CSV line with comma-separated values
     * @return Expense object with ID=0 (to be assigned by repository)
     */
    private Expense convertToObject(String line)
    {
        String[] parts = line.split(",");
        if(parts.length < 4)
            throw new IllegalArgumentException("Invalid CSV format: expected 4 fields, got " + parts.length);
        
        Expense e = new Expense();
        e.setDate(LocalDate.parse(parts[0].trim()));
        e.setDescription(parts[1].trim());
        e.setValue(Integer.parseInt(parts[2].trim()));
        e.setCategory(ExpenseCategory.valueOf(parts[3].trim()));
        return e;
    }

}
